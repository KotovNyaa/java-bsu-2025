# Ответы на вопросы по архитектуре и дизайну

Этот документ содержит ответы на ключевые теоретические вопросы, которые легли в основу проектирования системы.

## Основные вопросы из задания

### Что такое UUID?

**UUID (Universally Unique Identifier)** — это 128-битное число, используемое для идентификации информации в компьютерных системах. Главное преимущество UUID в том, что его можно сгенерировать где угодно (на клиенте, на сервере, в разных дата-центрах) и при этом быть практически уверенным в его уникальности без необходимости централизованной координации.

В данном проекте UUID используется для:
-   **Идентификации сущностей:** У каждого `User` и `Account` есть свой уникальный `id`.
-   **Идентификации транзакций:** Каждая операция имеет уникальный `id`, что важно для аудита.
-   **Обеспечения идемпотентности:** `idempotencyKey` — это тоже UUID, который гарантирует, что одна и та же операция не будет выполнена дважды.

### Является ли предложенная архитектура транзакции нормальной?

Архитектура объекта `Transaction` (UUID, timestamp, action, amount, account) является хорошей базой. В проекте она реализована через объект `TransactionCommand`. Рассмотрим её сильные и слабые стороны:

**Сильные стороны:**
-   **Наличие `UUID`** для уникальной идентификации.
-   **Наличие `timestamp`** для отслеживания времени операции.
-   **`action` (тип операции)** позволяет гибко управлять логикой с помощью паттернов Стратегия и Фабрика.
-   Использование **`BigDecimal` для `amount`** — это абсолютно правильное решение для финансовых расчетов, так как оно позволяет избежать ошибок округления, присущих `double` и `float`.

**Возможные улучшения:**
-   **Связь с пользователем:** Команда хранит `accountId`, но не `userId`. Это может усложнить аудит на уровне пользователя. Можно добавить `userId`.
-   **Детализация `action`:** Для операции `TRANSFER` требуется два счета (`sourceAccountId`, `destinationAccountId`). Это реализовано через отдельный фабричный метод, что является хорошим решением.
-   **Статус транзакции:** В `TransactionCommand` нет поля статуса (`PENDING`, `SUCCESS`, `FAILED`). Это состояние отслеживается косвенно через наличие записи в таблицах `transaction_outbox` или `processed_transactions`. Для более явного аудита можно было бы добавить поле статуса.

### Как достигается асинхронность и атомарность операций?

Атомарность и асинхронность — ключевые требования, которые реализованы с помощью комбинации нескольких паттернов и технологий:

1.  **Transactional Outbox (для надежной асинхронности):**
    -   Когда клиент отправляет запрос на операцию (например, перевод денег), API не выполняет его сразу. Вместо этого он создает команду и сохраняет ее в специальную таблицу `transaction_outbox` в базе данных.
    -   Этот шаг гарантирует, что намерение выполнить операцию надежно сохранено. Если система упадет, запись в `outbox` останется.

2.  **Фоновый поллер (`OutboxPoller`):**
    -   Отдельный поток периодически опрашивает таблицу `transaction_outbox`, забирает новые команды и отправляет их в обработчик.

3.  **LMAX Disruptor (для высокопроизводительной обработки):**
    -   Команды из `outbox` публикуются во внутрипроцессную (in-memory) очередь — `RingBuffer` фреймворка Disruptor.
    -   Disruptor организует конвейер, где каждая команда последовательно проходит через несколько обработчиков (проверка идемпотентности, выполнение бизнес-логики, сохранение результата). Это происходит очень быстро, так как все операции до финального сохранения выполняются в памяти.

4.  **Unit of Work и пакетное сохранение (для атомарности):**
    -   После выполнения бизнес-логики в памяти все изменения (обновленные балансы счетов, запись в журнал, удаление из `outbox`) собираются в один "пакет" (`BatchUnitOfWork`).
    -   Этот пакет сохраняется в базу данных в рамках **одной атомарной транзакции**. Либо все изменения успешно применяются, либо не применяется ни одно. Это гарантирует консистентность данных.

---

## Ключевые архитектурные решения (Why?)

### Зачем используется LMAX Disruptor, а не Kafka/RabbitMQ?

Disruptor — это **внутрипроцессная** библиотека, а не внешний брокер сообщений. Она выбрана для достижения **экстремально низкой задержки и высокой пропускной способности** внутри одного приложения. Она позволяет избежать накладных расходов на сетевое взаимодействие и сериализацию, что идеально для "горячего" ядра системы.

### Зачем хранить состояние счетов в памяти (`AccountState`)?

Это ключевая оптимизация производительности. Она позволяет выполнять бизнес-логику практически мгновенно, без медленных обращений к базе данных на каждую транзакцию. Риски потери данных минимизируются за счет журналирования (Write-Ahead Log) и регулярного сохранения изменений в БД.

### Зачем нужно собственное исключение `DataAccessException`?

Это позволяет абстрагировать бизнес-логику от деталей технологии доступа к данным (JDBC, JPA и т.д.). Сервисный слой ловит общее `DataAccessException`, а не специфичное `java.sql.SQLException`, что упрощает замену слоя персистентности в будущем.

### Почему транзакции не выполняются сразу, а помещаются в `transaction_outbox`?

Для повышения **надежности** и **отзывчивости**.
1.  **Надежность:** Гарантирует, что принятая задача не потеряется при сбое.
2.  **Отзывчивость:** API отвечает клиенту мгновенно, не дожидаясь завершения операции.

### Как клиент узнает о завершении транзакции?

Через паттерн **Observer (Наблюдатель)**. Клиент (UI) подписывается на уведомления. Когда транзакция успешно обрабатывается, бэкенд делает запись в таблицу `processed_transactions`. Фоновый процесс в API замечает это и уведомляет подписчиков.
